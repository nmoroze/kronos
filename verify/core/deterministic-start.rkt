#lang rosette/safe

(require
 (prefix-in ! (combine-in
               (only-in racket/base current-memory-use for/and for/list in-range values)
               (only-in racket/match match)
               (only-in racket/set set-add!)))
 rosutil
 shiva
 (only-in yosys get-field update-field update-fields))

(require
 "../clock-domains.rkt"
 "common.rkt"
 (except-in "../../opentitan.rkt" inputs) ; autogenerated
 (only-in "../peripheral/usb.rkt" usb-fixed-inputs)
 "../util/circuit.rkt")

(provide verify-core-det-start)

; We generate many fresh symbolics on each cycle, which are generally unused by
; the next cycle. This line prevents a memory leak that occurs because Rosette's
; default term cache keeps references to these otherwise unreachable symbolics.
(term-cache-ephemeral!)

(define (get-reg s reg)
  (let* ([lsb (* (sub1 reg) 32)]
         [msb (+ lsb 31)])
    (extract msb lsb (|top_earlgrey_n core.u_core.id_stage_i.registers_i.rf_reg_tmp| s))))

(define (get-pc s)
  (|top_earlgrey_n core.u_core.if_stage_i.pc_id_o| s))

(define (make-hint-list hints)
  (!for/list ([cond-hint hints]
              #:when (car cond-hint))
             (cdr cond-hint)))

(define peripheral-clock-domains
  ; shouldn't include CDC inputs in peripheral-clock-domains list, since verify-deterministic-start
  ; already overapproximates all inputs (and adds them to its list of allowed dependencies).
  (filter (lambda (f) (not (member f inputs)))
          (append spi-in-registers spi-out-registers usb-registers)))

(define (apply-hint-if condition hints)
  (if condition
      hints
      (list)))

(define (common-hints cycle sn)
  (define flag (bitvector->natural (get-reg sn 31)))
  (make-hint-list
   (list
    (cons #t (cons 'overapproximate peripheral-clock-domains))
    (cons (zero? (modulo cycle 100))
          'collect-garbage)
    (cons (<= cycle 150)
          (cons 'overapproximate '(spi_device.u_memory_2p.gen_srammem.u_mem.gen_mem_generic.u_impl_generic.b_rdata_o)))
    (cons (or (term? flag) (= flag 0))
          (cons 'overapproximate '(spi_device.u_memory_2p.gen_srammem.u_mem.gen_mem_generic.u_impl_generic.mem))))))

(define (aux-hints cycle sn)
  (append
   (if (= cycle 150)
       (list (cons 'concretize '(spi_device.u_rxf_ctrl.st)))
       (list))))

(define (gen-aux-hints q . args)
  (!match q
          ['general (append (apply aux-hints args) (apply common-hints args))]
          [_ #f]))

(define (main-hints cycle sn)
  (append
   (if (and (> cycle 1) (not (eq? (get-reg sn 11) (bv 0 32))))
       (list (cons 'abstract-or-overapprox-vector '(usbdev.u_memory_2p.gen_srammem.u_mem.gen_mem_generic.u_impl_generic.mem)))
       (list (cons 'overapproximate '(usbdev.u_memory_2p.gen_srammem.u_mem.gen_mem_generic.u_impl_generic.mem))))
   (apply-hint-if (= cycle 150)
                  (list (cons 'run-and-replace (cons gen-aux-hints '(spi_device.u_rxf_ctrl.st)))))
   (apply-hint-if (<= cycle 150)
                  (list (cons 'unsafe-custom-hint abstract-sram-wdata-and-byte-enable)))
   (apply-hint-if (< cycle 150)
                  (list (cons 'abstract '(
                                          spi_device.u_rxf_ctrl.st
                                          ; necessary to not let input to st grow every cycle:
                                          ; i think may eventually get reset
                                          spi_device.u_rxf_ctrl.sram_req
                                          ; eventually gets reset to zero
                                          spi_device.u_rx_fifo.fifo_rptr
                                          spi_device.u_memory_2p.b_rvalid_sram

                                          spi_device.u_rxf_ctrl.wptr
                                          spi_device.u_rxf_ctrl.pos
                                          spi_device.u_rxf_ctrl.cur_timer
                                          ;spi_device.u_rxf_ctrl.byte_enable

                                          spi_device.u_fwmode_arb.u_req_fifo.gen_normal_fifo.fifo_wptr
                                          spi_device.u_fwmode_arb.u_req_fifo.gen_normal_fifo.fifo_rptr
                                          spi_device.u_fwmode_arb.u_req_fifo.gen_normal_fifo.storage
                                          spi_device.u_fwmode_arb.gen_arb_ppc.u_reqarb.gen_normal_case.mask

                                          spi_device.u_reg.u_intr_state_rxlvl.q
                                          spi_device.u_reg.u_intr_state_rxf.q

                                          ; necessary to not let input to req_fifo.gen_normal_fifo.fifo_wptr to grow every cycle:
                                          spi_device.u_rxf_ctrl.sram_write))
                        ))
   (list
    (cons 'abstract '(
                      spi_device.u_reg.u_intr_state_txunderflow.q
                      spi_device.u_reg.u_intr_state_rxoverflow.q

                      usbdev.u_reg.u_intr_state_rx_pid_err.q
                      usbdev.u_reg.u_intr_state_rx_full.q
                      usbdev.u_reg.u_intr_state_rx_crc_err.q
                      usbdev.u_reg.u_intr_state_rx_bitstuff_err.q
                      usbdev.u_reg.u_intr_state_pkt_sent.q
                      usbdev.u_reg.u_intr_state_pkt_received.q
                      usbdev.u_reg.u_intr_state_link_suspend.q
                      usbdev.u_reg.u_intr_state_link_resume.q
                      usbdev.u_reg.u_intr_state_link_reset.q
                      usbdev.u_reg.u_intr_state_link_in_err.q
                      usbdev.u_reg.u_intr_state_host_lost.q
                      usbdev.u_reg.u_intr_state_frame.q
                      usbdev.u_reg.u_intr_state_disconnected.q
                      usbdev.u_reg.u_intr_state_connected.q
                      usbdev.u_reg.u_intr_state_av_empty.q
                      usbdev.u_reg.u_in_sent_sent11.q
                      usbdev.u_reg.u_in_sent_sent10.q
                      usbdev.u_reg.u_in_sent_sent9.q
                      usbdev.u_reg.u_in_sent_sent8.q
                      usbdev.u_reg.u_in_sent_sent7.q
                      usbdev.u_reg.u_in_sent_sent6.q
                      usbdev.u_reg.u_in_sent_sent5.q
                      usbdev.u_reg.u_in_sent_sent4.q
                      usbdev.u_reg.u_in_sent_sent3.q
                      usbdev.u_reg.u_in_sent_sent2.q
                      usbdev.u_reg.u_in_sent_sent1.q
                      usbdev.u_reg.u_in_sent_sent0.q)))))

(define (hints q . args)
  (!match q
          ['general (append (apply main-hints args) (apply common-hints args))]
          [_ #f]))

(define (abstract-sram-wdata-and-byte-enable sn allowed-dependencies)
  (define sram-wdata (get-field sn 'spi_device.u_rxf_ctrl.sram_wdata))
  (define byte-enable (get-field sn 'spi_device.u_rxf_ctrl.byte_enable))
  (define ok
    (and
     (!for/and ([i (!in-range 4)])
       (unsat?
        (let ([end   (sub1 (* 8 (add1 i)))]
              [start       (* 8       i)])
          (only-depends-on/unchecked (extract end start sram-wdata)
                                      allowed-dependencies
                                      #:invariant (equal? (extract i i byte-enable) (bv 1 1))))))
     (unsat? (only-depends-on/unchecked byte-enable allowed-dependencies))))
  (if ok
      (let* ([|sram-wdata[31:24]| (fresh-symbolic '|sram-wdata[31:24]| (bitvector 8))]
             [|sram-wdata[31:24]*| (fresh-symbolic '|sram-wdata[31:24]*| (bitvector 8))]
             [|sram-wdata[23:16]| (fresh-symbolic '|sram-wdata[23:16]| (bitvector 8))]
             [|sram-wdata[23:16]*| (fresh-symbolic '|sram-wdata[23:16]*| (bitvector 8))]
             [|sram-wdata[15:8]| (fresh-symbolic '|sram-wdata[15:8]| (bitvector 8))]
             [|sram-wdata[15:8]*| (fresh-symbolic '|sram-wdata[15:8]*| (bitvector 8))]
             [|sram-wdata[7:0]| (fresh-symbolic '|sram-wdata[7:0]| (bitvector 8))]
             [|sram-wdata[7:0]*| (fresh-symbolic '|sram-wdata[7:0]*| (bitvector 8))]
             [fresh-byte-enable (fresh-symbolic 'byte-enable (bitvector 4))]
             [new-sram-wdata
              (concat
               (if (equal? (extract 3 3 fresh-byte-enable) (bv 1 1))
                    |sram-wdata[31:24]*|
                    |sram-wdata[31:24]|)
               (if (equal? (extract 2 2 fresh-byte-enable) (bv 1 1))
                    |sram-wdata[23:16]*|
                    |sram-wdata[23:16]|)
               (if (equal? (extract 1 1 fresh-byte-enable) (bv 1 1))
                    |sram-wdata[15:8]*|
                    |sram-wdata[15:8]|)
               (if (equal? (extract 0 0 fresh-byte-enable) (bv 1 1))
                    |sram-wdata[7:0]*|
                    |sram-wdata[7:0]|))])
        (!set-add! allowed-dependencies |sram-wdata[31:24]*|)
        (!set-add! allowed-dependencies |sram-wdata[23:16]*|)
        (!set-add! allowed-dependencies |sram-wdata[15:8]*|)
        (!set-add! allowed-dependencies |sram-wdata[7:0]*|)
        (!set-add! allowed-dependencies fresh-byte-enable)
        (update-fields sn
                       (list (cons 'spi_device.u_rxf_ctrl.sram_wdata new-sram-wdata)
                             (cons 'spi_device.u_rxf_ctrl.byte_enable fresh-byte-enable))))
      (begin
        (printf "warning: failed to abstract sram-wdata and byte-enable~n")
        #f)))

(define (step s)
  (top_earlgrey_t
   (update-field s 'u_rom_rom.gen_mem_generic.u_impl_generic.mem rom-data)))

(define (watchdog sn)
  (define pc (get-pc sn))
  (when (< (bitvector->natural pc) #x8080)
    (printf "WARNING: PC below boot vector (exception likely occurred): ~a~n" pc))
  (when (term? pc)
    (displayln "WARNING: symbolic PC!")))

(define (make-debug memprofile)
  (define (debug cycle sn model)
    (when memprofile
      (printf "  symbolics: ~a~n" (length (symbolics sn)))
      (printf "  memory: ~a~n" (!current-memory-use)))

    (watchdog sn)
    #f)
  debug)

(define (verify-core-det-start #:debug-mode [debug-mode #f] #:memprofile [memprofile #f])
  ; how many cycles it should take to achieve proof
  (define expected-cycles 24516)
  ; how many cycles to try verification for
  ; larger than expected-cycles so that we can get insight into what state isn't
  ; being reset
  (define limit-cycles (+ expected-cycles 10))

  (define-values (cycles final-state allowed-deps)
    (verify-deterministic-start
     new-symbolic-top_earlgrey_s
     #:invariant top_earlgrey_i
     #:step step
     #:reset 'rst_ni
     #:reset-active 'low
     #:post-reset post-reset
     #:inputs inputs
     #:output-getters output-getters-phase-1
     #:fixed-fields usb-fixed-inputs
     #:hints hints
     #:debug (if (not debug-mode) (make-debug memprofile) (lambda _ #f))
     #:state-getters filtered-state-getters
     #:print-style 'full
     #:try-verify-after (- expected-cycles 10)
     #:limit limit-cycles))

  (!values (equal? cycles expected-cycles) final-state allowed-deps))
